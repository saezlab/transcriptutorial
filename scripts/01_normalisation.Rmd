---
title: "01_normalisation"
author: "Aurelien Dugourd"
date: "5/11/2020"
output: github_document
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### License Info

This program is free software: you can redistribute it and/or modify it under 
the terms of the GNU General Public License as published by the Free Software 
Foundation, either version 3 of the License, or (at your option) any later 
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY 
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
A PARTICULAR PURPOSE. See the GNU General Public License for more details.

Please check http://www.gnu.org/licenses/.

## Introduction

In the first part of our series of transcriptomics tutorials, we present an example normalisation strategy for omic datasets, using RNAseq data for the present case.

## Getting Started

We first load the required libraries. 

```{r, message=FALSE}
#Main libraries
library(readr)
library(vsn)

#Support functions also requires
library(ggplot2)
library(reshape)
library(pheatmap)
library(gridExtra)
library(grid)
library(cowplot)
library(ggrepel)
library(hexbin)

source("support_functions.R")
```

### Import the raw count dataframe
The data can be downloaded from: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE119931
Download the file: GSE119931_PANC1.FOXA2KO.genes.counts.txt.gz and decompress 
it inside the 'data' folder.

```{r}
## Raw counts table
GSE119931_PANC1_FOXA2KO_genes_counts <- as.data.frame(
  read_delim("../data/GSE119931_PANC1.FOXA2KO.genes.counts.txt", 
             "\t", escape_double = FALSE, trim_ws = TRUE)) 
```

The row names give the Ensembl IDs for the genes and the column names give information about the condition and sample from which the data was measured. For our analysis, we extract relevant columns from the raw counts table.

```{r}
count_df <- GSE119931_PANC1_FOXA2KO_genes_counts[,c(7:12)]
row.names(count_df) <- GSE119931_PANC1_FOXA2KO_genes_counts$Geneid
```

### Pre-processing and normalisation

First create a dataframe `targets` to summarise the experimental design. We extract the condition information from the original column names.

```{r}
targets <- as.data.frame(matrix(NA,length(names(count_df)),2))
names(targets) <- c("sample","condition")
targets$sample <- names(count_df)
targets$condition <- gsub(".Rep[0-9]$","",targets$sample)
```

We make some plots to check what the data looks like after just a log2
transformation (no normalisation)

```{r}
#First we remove rows that contain only 0
count_df <- count_df[rowSums(count_df) > 0,]
#remaining 0 have to be made as NA so that log2 transformation is possible
count_df[count_df == 0] <- NA
```

```{r}
#make the plots
plots <- magicPlotMakerLight(df = log2(count_df), targets = targets)
plot(plots[[1]]) #violins
plot(plots[[2]]) #PCA
```

From the violin plot, we can see that the distributions are bimodal. Usually
this is because a lots of genes are expressed under the RNAseq detection
threshold and will give rise to a noisy sub-distribution. We want to get rid of
those reads, so based on the violin plot, we decide to exclude any transcript
with less that 4 log2(counts).

Usually, a cleaned-up dataframe will have roughly between 9000 and 15000 measured genes.

```{r}
count_df[log2(count_df) < 4 ] <- NA

#remove rows (genes) which aren't well-measured in enough samples
count_df <- count_df[rowSums(is.na(count_df[,c(1:3)])) < 2,]
count_df <- count_df[rowSums(is.na(count_df[,c(4:6)])) < 2,]
```

### VSN normalisation

```{r}
#now we can normalise the cleaned dataframe using vsn
fit <- vsnMatrix(as.matrix(count_df)) #train vsn parameters

#make sure the mean/sd trend is not going crazy
meanSdPlot(fit)

#if good, normalise data with the trained parameters of vsn
count_df_vsn <- as.data.frame(vsn::predict(fit,as.matrix(count_df)))

```

We want to avoid finding big fragmented clusters of points in the means/sd plot. Here it looks pretty good so we can move forward.

```{r}
#now let's visualise the normalised data
plots <- magicPlotMakerLight(df = count_df_vsn, targets = targets) 
plot(plots[[1]]) #violins
plot(plots[[2]]) #PCA
```

From PCA, we see that conditions are well separated by the 2nd component. So it's ok, we will have some signal.

### Identifier Kung-Fu (optional)

Since currently our dataset uses Ensembl IDs, but most of our resources are based on UniProt or gene symbols, we need to do some identifier Kung-Fu!

```{r}
#this identifier matching dataframe was retrieved from uniprot:
gene_id_mapping_from_uniprot <- as.data.frame(
  read_delim("../support/gene_id_mapping_from_uniprot.tab", 
             "\t", escape_double = FALSE, trim_ws = TRUE))
gene_id_mapping_from_uniprot <- gene_id_mapping_from_uniprot[!is.na(gene_id_mapping_from_uniprot$`Gene names`),]

#let's make a pseudo dictionary to make the mapping efficient
ensembl_to_symbol <- gsub(" .*","",gene_id_mapping_from_uniprot$`Gene names`)
names(ensembl_to_symbol) <- gene_id_mapping_from_uniprot[,1]

#remove all genes that have no gene symbol from our count dataframe
row.names(count_df_vsn) <- gsub("[.][0-9]*","",row.names(count_df_vsn))
count_df_vsn <- count_df_vsn[row.names(count_df_vsn) %in% names(ensembl_to_symbol),]

#now let's convert ids with the pseudo dictionary
for(i in 1:length(count_df_vsn[,1]))
{
  row.names(count_df_vsn)[i] <- ensembl_to_symbol[row.names(count_df_vsn)[i]]
}
```

## Write count and target files for further analysis
```{r}
to_write <- count_df_vsn
to_write$gene <- row.names(to_write)
to_write <- to_write[,c(length(to_write[1,]),1:(length(to_write[1,])-1))]
write_csv(to_write, "../data/count_df_vsn.csv")
write_csv(targets, "../support/targets.csv")
```
## Session Info Details

```{r, echo=FALSE, eval=TRUE}
sessionInfo()
```

